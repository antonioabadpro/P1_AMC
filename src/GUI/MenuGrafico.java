/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */
package GUI;

import java.io.File;
import java.util.Random;
import java.util.Scanner;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.filechooser.FileNameExtensionFilter;
import libClases.Algoritmo;
import libClases.Fichero;
import libClases.Grafica;
import libClases.Punto;


/**
 * @version 06/11/24
 * @author Antonio Abad Hernandez Galvez
 */
public class MenuGrafico extends javax.swing.JFrame
{
    private Punto[] v_puntos; // Vector de Puntos cargado en memoria
    private static boolean caso_peor=false; // Indica si el Caso Peor esta desactivado (false) o activado (true)
    private int opc; // Opcion para el switch del Menu Principal
    private String texto_caso_peor; // Muestra en la Cabecera del Menu si el Caso Peor desactivado (OFF) o esta activado (ON)
    private Scanner sc = new Scanner(System.in); // Objeto para leer de teclado
    private String nomFicheroAleatorio = ""; // Nombre del Ultimo Fichero Aleatorio generado en el 'case 1'
    private String nomFichero = ""; // Nombre del Fichero actual cargado en Memoria
    
    // --------------------------- METODOS AUXILIARES ---------------------------
    
    /**
     * @return Devuelve 'true' si el Caso Peor esta activado y 'false' si el Caso Peor esta desactivado
     */
    
    public static boolean getCasoPeor()
    {
        return MenuGrafico.caso_peor;
    }
    
    /**
     * Genera un Vector de Puntos aleatorios (incluyendo el Caso Peor) con el tamaño del Vector introducido por parametro
     * @param longitud Es el tamaño que tiene el Vector Aleatorio que queremos generar
     * @return Devuelve el Vector de Puntos con los Puntos generados aleatoriamente
     */
    public static Punto[] generarVector(int longitud)
    {
        Punto v_puntos[]=new Punto[longitud];
        double x; // Coordenada X del Punto generada aleatoriamente [1 - 5000]
        double y; // Coordenada Y del Punto generada aleatoriamente [1 - 5000]
        int num;
        int den;
        double num_y; // Ajusta el valor de la coordenada 'y'
        double variabilidad; // Para que NO se generen Puntos con las mismas coordenadas
        Random aleatorio=new Random(System.nanoTime());
        
        if(MenuGrafico.caso_peor==false)
        {
            for(int i=0; i<longitud; i++)
            {
                num=1+aleatorio.nextInt(4000-1+1); // Nº aleatorio [1-4000]
                den=7+aleatorio.nextInt(17-7+1); // Nº aleatorio [7-17]
                x=num/((double)den+0.37);
                y=(1+aleatorio.nextInt(4000-1+1))/((double)(7+aleatorio.nextInt(17-7+1))+0.37);

                v_puntos[i]=new Punto(i+1, x, y); // Creamos el nuevo objeto de tipo Punto en la posicion 'i' del vector
            }
        }
        else
        {
            //x=1+aleatorio.nextDouble(5000-1+1);
            x=1;
            for(int i=0; i<longitud; i++)
            {
                variabilidad=1+aleatorio.nextDouble(5000-1+1);

                y=variabilidad/(double) i+1+i*0.100; // Generamos la coordenada 'y' utilizando 'variabilidad' que depende de 'y' para obtener una mayor variabilidad

                num_y=0+aleatorio.nextDouble(2-0+1); // Generamos un nº aleatorio [0-2] para ajustar la coordenada 'y'
                y=y+((i%500)-num_y*(1+aleatorio.nextInt(100-1+1)));

                v_puntos[i]=new Punto(i+1, x, y); // Creamos el nuevo objeto de tipo Punto en la posicion 'i' del vector
            }
        }
        return v_puntos;        
    }
    
    /**
     * Crea una copia del Vector de Puntos que le entra por parametro 'v_original'
     * @param v_original Es el Vector de Puntos original que quieremos copiar o duplicar
     * @return Devuelve el Vector Copia 'v_copia' que tiene los mismos valores que 'v_original'
     */
     public static Punto[] copiarVector(Punto[] v_original)
     {
        Punto[] v_copia=new Punto[v_original.length];

        for (int i=0; i<v_original.length; i++)
        {
            v_copia[i]=new Punto(v_original[i].getId(), v_original[i].getX(), v_original[i].getY());
        }
        return v_copia;
    }
    
    /**
     * Creates new form MenuGrafico
     */
    public MenuGrafico() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        menuCrearAletorio = new javax.swing.JButton();
        menuCargar_en_Memoria = new javax.swing.JButton();
        menuComprobarEstrategias = new javax.swing.JButton();
        menuCompararTodasEstrategias = new javax.swing.JButton();
        menuComparar2Estrategias = new javax.swing.JButton();
        chk_casoPeor = new javax.swing.JCheckBox();
        menuAcercade = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setMaximumSize(new java.awt.Dimension(1920, 1080));
        setName("menuGrafico"); // NOI18N
        setPreferredSize(new java.awt.Dimension(1536, 864));
        setResizable(false);

        jLabel1.setFont(new java.awt.Font("Candara", 1, 24)); // NOI18N
        jLabel1.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel1.setText("Práctica 1: Estrategias Algorítmicas");

        jLabel3.setIcon(new javax.swing.ImageIcon(getClass().getResource("/imagenes/fondo_principal.png"))); // NOI18N

        jLabel2.setBackground(new java.awt.Color(153, 153, 153));
        jLabel2.setFont(new java.awt.Font("Segoe UI", 1, 24)); // NOI18N
        jLabel2.setForeground(new java.awt.Color(153, 0, 153));
        jLabel2.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel2.setText("MENÚ PRINCIPAL");
        jLabel2.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);

        menuCrearAletorio.setFont(new java.awt.Font("Segoe UI", 0, 14)); // NOI18N
        menuCrearAletorio.setIcon(new javax.swing.ImageIcon(getClass().getResource("/imagenes/aleatorio.png"))); // NOI18N
        menuCrearAletorio.setText("Crear Fichero .TSP aleatorio");
        menuCrearAletorio.setToolTipText("Permite crear un fichero en formato .tsp con datos aleatorios. \nDebe preguntar cuántos datos generar y guardarlo en disco con el nombre datasetN.tsp, \nsiendo N el tamaño del conjunto de datos creado.");
        menuCrearAletorio.setActionCommand("menuCrear_Aleatorio");
        menuCrearAletorio.setMaximumSize(new java.awt.Dimension(171, 23));
        menuCrearAletorio.setMinimumSize(new java.awt.Dimension(171, 23));
        menuCrearAletorio.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menuCrearAletorioActionPerformed(evt);
            }
        });

        menuCargar_en_Memoria.setFont(new java.awt.Font("Segoe UI", 0, 14)); // NOI18N
        menuCargar_en_Memoria.setIcon(new javax.swing.ImageIcon(getClass().getResource("/imagenes/ram.jpg"))); // NOI18N
        menuCargar_en_Memoria.setText("Cargar un TSP en Memoria");
        menuCargar_en_Memoria.setToolTipText("Esta opción debe permitir cargar el dataset con un conjunto de datos generados de forma aleatoria (en ese caso el dataset creado debe guardarse en disco en formato .tsp con el nombre indicado en el apartado 1 anterior) o con los datos leídos de un fichero .tsp ya existente.  ");
        menuCargar_en_Memoria.setActionCommand("menuCargar_TSP_MEmoria");
        menuCargar_en_Memoria.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menuCargar_en_MemoriaActionPerformed(evt);
            }
        });

        menuComprobarEstrategias.setFont(new java.awt.Font("Segoe UI", 0, 14)); // NOI18N
        menuComprobarEstrategias.setIcon(new javax.swing.ImageIcon(getClass().getResource("/imagenes/comprobar_estrategias.png"))); // NOI18N
        menuComprobarEstrategias.setText("Comprobar Estrategias");
        menuComprobarEstrategias.setToolTipText("Esta opción debe mostrar en pantalla el resultado de aplicar las 4 estrategias sobre el dataset cargado en memoria");
        menuComprobarEstrategias.setActionCommand("menuComprobar_Estrategias");
        menuComprobarEstrategias.setIconTextGap(15);
        menuComprobarEstrategias.setMaximumSize(new java.awt.Dimension(171, 23));
        menuComprobarEstrategias.setMinimumSize(new java.awt.Dimension(171, 23));
        menuComprobarEstrategias.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menuComprobarEstrategiasActionPerformed(evt);
            }
        });

        menuCompararTodasEstrategias.setFont(new java.awt.Font("Segoe UI", 0, 14)); // NOI18N
        menuCompararTodasEstrategias.setIcon(new javax.swing.ImageIcon(getClass().getResource("/imagenes/estrategias.png"))); // NOI18N
        menuCompararTodasEstrategias.setText("Comparar todas las Estrategias");
        menuCompararTodasEstrategias.setToolTipText("Esta opción debe permitir comparar el rendimiento de cada algoritmo con diferentes tamaños de datos.");
        menuCompararTodasEstrategias.setActionCommand("menuComparar_Todas_Estrategias");
        menuCompararTodasEstrategias.setHorizontalTextPosition(javax.swing.SwingConstants.RIGHT);
        menuCompararTodasEstrategias.setIconTextGap(14);
        menuCompararTodasEstrategias.setInheritsPopupMenu(true);
        menuCompararTodasEstrategias.setMaximumSize(new java.awt.Dimension(171, 23));
        menuCompararTodasEstrategias.setMinimumSize(new java.awt.Dimension(171, 23));
        menuCompararTodasEstrategias.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menuCompararTodasEstrategiasActionPerformed(evt);
            }
        });

        menuComparar2Estrategias.setFont(new java.awt.Font("Segoe UI", 0, 14)); // NOI18N
        menuComparar2Estrategias.setIcon(new javax.swing.ImageIcon(getClass().getResource("/imagenes/comparar_dos_estrategias.png"))); // NOI18N
        menuComparar2Estrategias.setText("Comparar 2 Estrategias");
        menuComparar2Estrategias.setToolTipText("Esta opción debe permitir comparar el rendimiento de 2 algoritmos entre sí, con diferentes tamaños de datos");
        menuComparar2Estrategias.setActionCommand("menuComparar_Todas_Estrategias");
        menuComparar2Estrategias.setHorizontalTextPosition(javax.swing.SwingConstants.RIGHT);
        menuComparar2Estrategias.setIconTextGap(40);
        menuComparar2Estrategias.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menuComparar2EstrategiasActionPerformed(evt);
            }
        });

        chk_casoPeor.setText("Peor Caso");
        chk_casoPeor.setToolTipText("Los datos generados de forma que todos los puntos están sobre la misma vertical (PEOR CASO)");
        chk_casoPeor.setActionCommand("0");
        chk_casoPeor.setName("chk_casoPeor"); // NOI18N
        chk_casoPeor.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                chk_casoPeorActionPerformed(evt);
            }
        });

        menuAcercade.setFont(new java.awt.Font("Segoe UI", 0, 14)); // NOI18N
        menuAcercade.setIcon(new javax.swing.ImageIcon(getClass().getResource("/imagenes/acercade.png"))); // NOI18N
        menuAcercade.setText("Acerca de..");
        menuAcercade.setToolTipText("Información del desarrrollador de la práctica");
        menuAcercade.setActionCommand("menuAcercade");
        menuAcercade.setIconTextGap(20);
        menuAcercade.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menuAcercadeActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(31, 31, 31)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(menuCargar_en_Memoria, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(menuCrearAletorio, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(menuComprobarEstrategias, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(menuCompararTodasEstrategias, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jLabel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(menuComparar2Estrategias, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(menuAcercade, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(124, 124, 124)
                        .addComponent(chk_casoPeor, javax.swing.GroupLayout.PREFERRED_SIZE, 86, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jLabel3)
                .addGap(309, 309, 309))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addGap(0, 0, Short.MAX_VALUE)
                .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 1492, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        jPanel1Layout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {menuCargar_en_Memoria, menuCompararTodasEstrategias, menuComprobarEstrategias, menuCrearAletorio});

        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(42, 42, 42)
                .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 26, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(51, 51, 51)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(menuCrearAletorio, javax.swing.GroupLayout.PREFERRED_SIZE, 55, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(menuCargar_en_Memoria, javax.swing.GroupLayout.PREFERRED_SIZE, 54, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(menuComprobarEstrategias, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(menuCompararTodasEstrategias, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(menuComparar2Estrategias)
                        .addGap(36, 36, 36)
                        .addComponent(chk_casoPeor, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGap(18, 18, 18)
                        .addComponent(menuAcercade)
                        .addGap(315, 315, 315))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(jLabel3)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
        );

        jPanel1Layout.linkSize(javax.swing.SwingConstants.VERTICAL, new java.awt.Component[] {menuCargar_en_Memoria, menuCompararTodasEstrategias, menuComprobarEstrategias, menuCrearAletorio});

        chk_casoPeor.getAccessibleContext().setAccessibleName("chkpeorcaso");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, 754, javax.swing.GroupLayout.PREFERRED_SIZE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Informacion del Proyecto
     */
    private void menuAcercadeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuAcercadeActionPerformed

        AcercaDe vcreditos = new AcercaDe();
        vcreditos.setLocationRelativeTo(null);
        vcreditos.setVisible(true);
    }//GEN-LAST:event_menuAcercadeActionPerformed

    /**
     * Boton (Check) para activar o desactivar el Caso Peor
     */
    private void chk_casoPeorActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_chk_casoPeorActionPerformed

        if(this.chk_casoPeor.isSelected()) // Si el check esta seleccionado
        {
            MenuGrafico.caso_peor=true;
        }
        else
        {
            MenuGrafico.caso_peor=false;
        }
    }//GEN-LAST:event_chk_casoPeorActionPerformed

    /**
     * Submenu (Frame) para el case 5
     * @param evt 
     */
    private void menuComparar2EstrategiasActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuComparar2EstrategiasActionPerformed

        CompararDosAlgoritmos ventanaDosEstrategias = new CompararDosAlgoritmos(MenuGrafico.caso_peor);
        ventanaDosEstrategias.setLocation(0, 450);
        ventanaDosEstrategias.setVisible(true);
    }//GEN-LAST:event_menuComparar2EstrategiasActionPerformed

    /**
     * Boton para el case 4
     * @param evt 
     */
    private void menuCompararTodasEstrategiasActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuCompararTodasEstrategiasActionPerformed

        Punto[] v_algoritmo=null; // Vector de Puntos que devuelve el Algortimo 'i'
        Punto[] v_copia=null; // Vector de Puntos que es una copia del Vector Original cargado en Memoria para que cada Algoritmo trabaje con el Vector Original
        double tInicio=0; // Tiempo Inicial de la ejecucion del Algoritmo
        double tFin=0; // Tiempo Final de la ejecucion del Algoritmo
        double duracion=0; // Tiempo total de duracion de la ejecucion del Algoritmo (tFin - tInicio)
        double dis_min=0; // Distancia minima entre los 2 Puntos mas cercanos del Fichero
        String v_nomAlgoritmo[]=new String[4]; // Vector que contiene el Nombre de los 4 Algoritmos posibles que hay en el Programa
        String nomAlgoritmo; // Contiene el Nombre de los 4 Algoritmos Concatenados
        StringBuilder salida=new StringBuilder(); // Salida de la Consola que ahora mostramos en el Frame
        String tituloVentana; // Titulo de la ventana de la compartiva de los 4 algoritmos

        // Variables para realizar el Caso Medio
        int numCasoMedio = 100; // Numero de Vectores de Puntos que queremos generar aleatoriamente para realizar el Caso Medio
        int talla_inicial = 1000;
        int talla_final = 5000;
        int incremento = 1000;
        int num_tallas = talla_final / incremento; // Determina la longitud del Vector de tiempos que vamos a crear
        int talla=talla_inicial; // Talla para mostrarla por Consola

        // Variables para almacenar los tiempos de cada Algoritmo
        double v_tiempo_acumulado[] = new double[4]; // Vector de tiempos para almacenar el tiempo de cada Algoritmo despues de hacer el Caso Medio
        double v_tiempos_A1[]=new double[num_tallas]; // Vector de tiempos del Algoritmo 1
        double v_tiempos_A2[]=new double[num_tallas]; // Vector de tiempos del Algoritmo 2
        double v_tiempos_A3[]=new double[num_tallas]; // Vector de tiempos del Algoritmo 3
        double v_tiempos_A4[]=new double[num_tallas]; // Vector de tiempos del Algoritmo 4
        int pos_tiempo=0;

        v_nomAlgoritmo[0]="Exhaustivo";
        v_nomAlgoritmo[1]="ExhaustivoPoda";
        v_nomAlgoritmo[2]="DivideVenceras";
        v_nomAlgoritmo[3]="DyVMejorado";

        nomAlgoritmo=v_nomAlgoritmo[0]+v_nomAlgoritmo[1]+v_nomAlgoritmo[2]+v_nomAlgoritmo[3];

        // Realizamos el Caso Medio para cada Algoritmo (generamos 100 vectores de Puntos aleatorios) para que no se produzcan resultados inconsistentes
        for(int i=talla_inicial; i<=talla_final; i=i+incremento)
        {
            for(int j=0; j<numCasoMedio; j++) // Generamos 'numCasoMedio=100' vectores de Puntos para realizar el Caso Medio y NO generar 1 unico Vector de Puntos que pueda provocar resultados incoherentes
            {
                v_puntos=MenuGrafico.generarVector(i); // Generamos un vector de Puntos aleatorios de talla 'i'

                // Comparamos cada algoritmo para cada vector de puntos generados y vamos sumando los tiempos de cada Algoritmos (Igual que en el case 3)
                for(int k=0; k<4; k++)
                {
                    v_copia=MenuGrafico.copiarVector(v_puntos); // Copiamos los Datos del Vector para trabajar con el y NO modificar los valores del Vector Original

                    Algoritmo.setContador(0); // Reseteamos el Contador del numero de llamadas al metodo 'distancia()' para el Algoritmo 'k'
                    Algoritmo.resetDistanciaMinima(); // Resetamos el valor de la Distancia Minima para el Algoritmo 'k'
                    tInicio = System.nanoTime(); // Iniciamos el tiempo del Algoritmo 'i'

                    switch (v_nomAlgoritmo[k])
                    {
                        case "Exhaustivo":
                        {
                            v_algoritmo = Algoritmo.busquedaExhaustiva(v_copia, 0, v_copia.length - 1);
                        };break;

                        case "ExhaustivoPoda":
                        {
                            Algoritmo.QuickSort(v_copia, 0, v_copia.length - 1, 'x'); // Ordenamos el Vector de Puntos antes de llamar al Algoritmo
                            v_algoritmo = Algoritmo.busquedaExhaustivaPoda(v_copia, 0, v_copia.length - 1);
                        };break;

                        case "DivideVenceras":
                        {
                            Algoritmo.QuickSort(v_copia, 0, v_copia.length - 1, 'x'); // Ordenamos el Vector de Puntos antes de llamar al Algoritmo
                            v_algoritmo = Algoritmo.busquedaDyV(v_copia, 0, v_copia.length - 1);
                        };break;

                        case "DyVMejorado":
                        {
                            Algoritmo.QuickSort(v_copia, 0, v_copia.length-1, 'x'); // Ordenamos el Vector de Puntos antes de llamar al Algoritmo
                            v_algoritmo=Algoritmo.busquedaDyV_mejorada(v_copia, 0, v_copia.length-1);
                        };break;
                    }

                    // Calculamos la distancia minima entre los 2 Puntos mas cercanos del Ficheros calculados por el Algoritmo 'i'
                    dis_min = Algoritmo.getDistanciaMinima();
                    // Calculamos la duracion del Algoritmo 'i'
                    tFin = System.nanoTime();
                    duracion = (tFin - tInicio) / 1e6; // Convertimos la duracion en 'ns' a 'ms'
                    v_tiempo_acumulado[k] = v_tiempo_acumulado[k] + duracion; // Acumulamos la duracion de cada Algoritmo en el Vector de tiempos 'v_tiempos' para ver el tiempo total que ha tardado cada Algoritmo y despues hacer el Caso Medio
                }
            }

            // Almacenamos los tiempos y las distancias calculadas de cada Algoritmo
            v_tiempos_A1[pos_tiempo]=v_tiempo_acumulado[0]/num_tallas;
            v_tiempos_A2[pos_tiempo]=v_tiempo_acumulado[1]/num_tallas;
            v_tiempos_A3[pos_tiempo]=v_tiempo_acumulado[2]/num_tallas;
            v_tiempos_A4[pos_tiempo]=v_tiempo_acumulado[3]/num_tallas;
            pos_tiempo++;
        }

        // Escribimos las Cabeceras de la Salida por Pantalla
        salida.append(String.format("%-10s %-16s %-16s %-16s %-16s%n", "" , v_nomAlgoritmo[0], v_nomAlgoritmo[1], v_nomAlgoritmo[2], v_nomAlgoritmo[3]));
        salida.append(String.format("%-10s %-16s %-16s %-16s %-16s%n", "Talla", "Tiempo (ms)", "Tiempo (ms)", "Tiempo (ms)", "Tiempo (ms)"));
        // Mostramos los Resultados de los Algoritmos para cada talla
        for(int i=0;i<num_tallas; i++)
        {
            salida.append(String.format("%-10s ", talla)); // Mostramos la talla 'i'
            salida.append(String.format("%-16.6f ", v_tiempos_A1[i]));
            salida.append(String.format("%-16.6f ", v_tiempos_A2[i]));
            salida.append(String.format("%-16.6f ", v_tiempos_A3[i]));
            salida.append(String.format("%-16.6f ", v_tiempos_A4[i]) + "\n");

            talla=talla+incremento;
        }

        // Generamos el Fichero .DAT con el resultado de los Algoritmos
        Fichero.escribirFicheroDAT(v_nomAlgoritmo, v_tiempos_A1, v_tiempos_A2, v_tiempos_A3, v_tiempos_A4, talla_inicial, incremento);
        salida.append("Fichero '" + nomAlgoritmo + ".dat' generado");
        // Comprobamos si el Caso Peor esta activado para mostrarlo en el Nombre de la Grafica
        if(caso_peor==true)
        {
            nomAlgoritmo=nomAlgoritmo + " (Peor Caso)";
        }
        
        // Mostramos por Pantalla el resultado
        tituloVentana="Resultado de COMPARAR TODAS LAS ESTRATEGIAS";
        VentanaResultado v = new VentanaResultado();
        v.setLocation(0, 33);
        v.setSize(700, 300);
        v.setTitle(tituloVentana);
        if(MenuGrafico.caso_peor==true) // Si el Caso Peor esta activado, cambiamos el titulo de la Ventana del muestreo de tiempos
        {
            tituloVentana=tituloVentana + " (Peor Caso)";
            v.setTitle(tituloVentana);
        }
        v.mostrarVentana(salida.toString());
        v.setVisible(true);

        // Generamos la grafica comparativa de los 2 Algoritmos
        Grafica g=new Grafica(nomAlgoritmo, "Talla", "Tiempo (ms)", 1); // Grafica de tipo 1 (Comparativa de todos los Algoritmos)
        g.setLocation(705, 33);
        g.agregarGraficaTodos(v_nomAlgoritmo, v_tiempos_A1, v_tiempos_A2, v_tiempos_A3, v_tiempos_A4, talla_inicial, incremento);
        g.setVisible(true);
    }//GEN-LAST:event_menuCompararTodasEstrategiasActionPerformed

    /**
     * Boton para el case 3
     * @param evt 
     */
    private void menuComprobarEstrategiasActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuComprobarEstrategiasActionPerformed

        Punto[] v_algoritmo=null; // Vector de Puntos que devuelve el Algortimo 'i'
        Punto[] v_copia = null; // Vector de Puntos que es una copia del Vector Original cargado en Memoria para que cada Algoritmo trabaje con el Vector Original
        double tInicio = 0; // Tiempo Inicial de la ejecucion del Algoritmo
        double tFin = 0; // Tiempo Final de la ejecucion del Algoritmo
        double duracion = 0; // Tiempo total de duracion de la ejecucion del Algoritmo (tFin - tInicio)
        double dis_min = 0; // Distancia minima entre los 2 Puntos mas cercanos del Fichero
        double v_tiempos[] = new double[4]; // Vector de tiempos para almacenar el tiempo de cada Algoritmo
        String v_nomAlgoritmo[] = new String[4]; // Vector que contiene el Nombre de los 4 Algoritmos posibles que hay en el Programa
        String nomAlgoritmo;
        StringBuilder salida=new StringBuilder(); // Salida de la Consola que ahora mostramos en el Frame

        v_nomAlgoritmo[0] = "Exhaustivo";
        v_nomAlgoritmo[1] = "ExhaustivoPoda";
        v_nomAlgoritmo[2] = "DivideVenceras";
        v_nomAlgoritmo[3]= "DyVMejorado";

        if(v_puntos==null) // Si NO hemos cargado un Dataset en Memoria (NO hay elementos en el Vector de Puntos)
        {
            JOptionPane.showMessageDialog(this, "NO hay ningun dataset cargado en Memoria", "ERROR", JOptionPane.ERROR_MESSAGE);
        }
        else // Si hemos cargado un Dataset en Memoria (Hay elementos en el Vector de Puntos)
        {
            salida.append("Dataset en Memoria: " + nomFichero);

            // Mostramos la Cabecera de la Salida por Pantalla
            salida.append("\n----------------------------------------------------------------------------------------------------------------------------------------------------------\n");
            salida.append(String.format("%-22s %-40s %-40s %-18s %-15s %-16s%n", "Estrategia", "Punto 1", "Punto 2", "Distancia", "Calculadas", "Tiempo (ms)"));

            for(int i=0; i<4; i++)
            {
                v_copia = MenuGrafico.copiarVector(v_puntos); // Copiamos los Datos del Vector para trabajar con el y NO modificar los valores del Vector Original

                Algoritmo.setContador(0); // Reseteamos el Contador del numero de llamadas al metodo 'distancia()' para el Algoritmo 'i'
                Algoritmo.resetDistanciaMinima(); // Resetamos el valor de la Distancia Minima para el Algoritmo 'i'
                tInicio = System.nanoTime(); // Iniciamos el tiempo del Algoritmo 'i'
                switch (v_nomAlgoritmo[i])
                {
                    case "Exhaustivo":
                    {
                        v_algoritmo = Algoritmo.busquedaExhaustiva(v_copia, 0, v_copia.length - 1);
                    };break;

                    case "ExhaustivoPoda":
                    {
                        Algoritmo.QuickSort(v_copia, 0, v_copia.length - 1, 'x'); // Ordenamos el Vector de Puntos antes de llamar al Algoritmo DyV Mejorado
                        v_algoritmo = Algoritmo.busquedaExhaustivaPoda(v_copia, 0, v_copia.length - 1);
                    };break;

                    case "DivideVenceras":
                    {
                        Algoritmo.QuickSort(v_copia, 0, v_copia.length - 1, 'x'); // Ordenamos el Vector de Puntos antes de llamar al Algoritmo DyV Mejorado
                        v_algoritmo = Algoritmo.busquedaDyV(v_copia, 0, v_copia.length - 1);
                    };break;

                    case "DyVMejorado":
                    {
                        Algoritmo.QuickSort(v_copia, 0, v_copia.length-1, 'x'); // Ordenamos el Vector de Puntos antes de llamar al Algoritmo DyV Mejorado
                        v_algoritmo=Algoritmo.busquedaDyV_mejorada(v_copia, 0, v_copia.length-1);
                    };break;
                }

                // Calculamos la distancia minima entre los 2 Puntos mas cercanos del Ficheros calculados por el Algoritmo 'i'
                dis_min = Algoritmo.getDistanciaMinima();
                // Calculamos la duracion del Algoritmo 'i'
                tFin = System.nanoTime();
                duracion = (tFin - tInicio) / 1e6; // Convertimos la duracion en 'ns' a 'ms'
                v_tiempos[i] = duracion; // Almacenamos la duracion de cada Algoritmo en el Vector de tiempos 'v_tiempos'

                // Mostramos los Resultados del Algoritmo
                salida.append(String.format("%-22s %-40s %-40s %-18.8f %-15s %-16.4f%n", v_nomAlgoritmo[i], v_algoritmo[0], v_algoritmo[1], dis_min, Algoritmo.getContador(), v_tiempos[i]));
                
                // Generamos el Fichero .TSP del Algoritmo 'i'
                Fichero.escribirFicheroArray(v_copia, v_nomAlgoritmo[i]);
            }
            // Mostramos por Pantalla el resultado
            VentanaResultado v=new VentanaResultado();
            v.setLocation(0, 33);
            v.setTitle("Resultado de COMPROBAR ESTRATEGIAS");
            v.mostrarVentana(salida.toString());
            v.setVisible(true);
        }
    }//GEN-LAST:event_menuComprobarEstrategiasActionPerformed

    /**
     * Boton para el case 2
     * @param evt 
     */
    private void menuCargar_en_MemoriaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuCargar_en_MemoriaActionPerformed

        // Control de los eventos que se disparan al pulsar boton ACEPTAR o boton CANCELAR
        File fichero;
        JFileChooser fileChooser = new JFileChooser();
        
        File dirActual = new File(System.getProperty("user.dir")); // Iniciamos en el directorio de trabajo
        fileChooser.setAcceptAllFileFilterUsed(false);
        fileChooser.setCurrentDirectory(dirActual);
        FileNameExtensionFilter filtro = new FileNameExtensionFilter("Ficheros TSP", "tsp"); // Selecciona *.TSP 
        fileChooser.addChoosableFileFilter(filtro);  

        fileChooser.setApproveButtonText("Cargar");
        fileChooser.setApproveButtonToolTipText("Pulsa para cargar el fichero en Memoria");

        fileChooser.setDialogTitle("CARGAR FICHERO EN MEMORIA");
        
        int resultado = fileChooser.showOpenDialog(this);
        if (resultado == JFileChooser.APPROVE_OPTION) // Si seleccionamos un Fichero desde la Ventana 'CargarFicheroMemoria'
        {
            fichero = fileChooser.getSelectedFile();
            
            v_puntos=Fichero.leerFichero(fichero);
            
            JOptionPane.showMessageDialog(null,"Fichero '"+ fichero.getName() + "' cargado con éxito.", "Cargar TSP en Memoria", JOptionPane.INFORMATION_MESSAGE);
            
            this.nomFichero=fichero.getName();
        }
        /*
        else 
        {
            if (resultado == JFileChooser.CANCEL_OPTION) // Si cerramos la Ventana de selccionar el Fichero 'CargarFicheroMemoria'
            {
                JOptionPane.showMessageDialog(null,"Operación Cancelada"); // No realizar ninguna acción
            }
        }
        */
    }//GEN-LAST:event_menuCargar_en_MemoriaActionPerformed

    /**
     * Boton para el case 1
     * @param evt 
     */
    private void menuCrearAletorioActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuCrearAletorioActionPerformed
        
        CrearFicheroAleatorio creafichero =new CrearFicheroAleatorio();
        creafichero.setLocationRelativeTo(null);
        creafichero.setVisible(true);
    }//GEN-LAST:event_menuCrearAletorioActionPerformed

    /**
     * Codigo main() del Menu Principal
     */
    public static void main(String args[])
    {
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(MenuGrafico.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(MenuGrafico.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(MenuGrafico.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(MenuGrafico.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        
        MenuGrafico m=new MenuGrafico();
        m.setTitle("Antonio Abad Hernandez Galvez -> Practica 1 (Estrategias Algoritmicas)");
        m.setVisible(true);
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JCheckBox chk_casoPeor;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JButton menuAcercade;
    private javax.swing.JButton menuCargar_en_Memoria;
    private javax.swing.JButton menuComparar2Estrategias;
    private javax.swing.JButton menuCompararTodasEstrategias;
    private javax.swing.JButton menuComprobarEstrategias;
    private javax.swing.JButton menuCrearAletorio;
    // End of variables declaration//GEN-END:variables

};
